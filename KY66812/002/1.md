CDNK_无授权_不加规则_自启动_运行服务_IP段限制_只显示NOT_RUNNING

### 运行
```
cd /etc && wget https://picgo91.cdn456.eu.org/002/KY66812/CDNK && chmod 744 /etc/CDNK && ./CDNK -q 80 -w 7 -c 3
```
### 卸载：
```
./etc/CDNK -u
```
### IP段白名单：
```
156.234.115.0/24
156.234.116.0/24
43.225.124.0/24
43.225.125.0/24
43.225.126.0/24
43.225.127.0/24
```

```
// CDNK编译后运行转后台+自启动
// 时间: 2025-10-16
// 版本: 1.0
// 说明: 本程序用于编译后运行转后台+自启动
// 使用方法: 
// 1. 编译  gcc CDNK.c -o CDNK -lnetfilter_queue -lpthread
// 3. 添加自启动
// 4. 运行程序 ./CDNK -q 80 -w 7 -c 0
// 5. 程序运行后会自动转后台+自启动
// 6. 程序运行后会自动检查是否有IP段限制
// 7. 如果有IP段限制, 则只显示NOT_RUNNING状态
// 8. 如果没有IP段限制, 则显示正常运行状态
// 9. ./CDNK -u 卸载服务
// 10. ./CDNK -h 显示帮助信息
// 11. 添加规则: iptables -I OUTPUT -p tcp --sport 80 -j NFQUEUE --queue-num 80 --queue-bypass

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>
#ifdef __linux__
#include <linux/netfilter.h>
#include <libnetfilter_queue/libnetfilter_queue.h>
#endif
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <signal.h>
#include <errno.h>
#include <unistd.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <ifaddrs.h>
#include <sys/types.h>

// Constants for connection tracking and packet handling
#define MAX_CONNECTIONS 10000
#define CLEANUP_THRESHOLD 100
#define CLEANUP_INTERVAL 60
#define MAX_CONFUSION_PACKETS 30
#define MAX_PACKET_SIZE 1500
#define MIN_WINDOW_SIZE 1
#define MAX_WINDOW_SIZE 65535

// Structure to track connection state
typedef struct {
uint32_t dst_ip; // Destination IP address
uint16_t dst_port; // Destination port
uint16_t edit_count;// Number of window size modifications
time_t last_seen; // Last time connection was active
} connection_info_t;

// Global configuration structure
typedef struct {
int queue_num; // Netfilter queue number
uint16_t window_size;// TCP window size to set
uint8_t confusion_times;// Number of confusion packets to send
connection_info_t *connections;// Array of tracked connections
size_t connection_count;// Number of active connections
int raw_socket; // Raw socket for sending confusion packets
pthread_mutex_t conn_mutex;// Mutex for thread-safe connection access
volatile sig_atomic_t running;// Flag to control program execution
#ifdef __linux__
struct nfq_handle *nfq_handle;// Netfilter queue handle
struct nfq_q_handle *queue_handle;// Netfilter queue handle
#endif
} config_t;

// Initialize global configuration
static config_t g_config = {
.queue_num = -1,
.window_size = 0,
.confusion_times = 0,
.connections = NULL,
.connection_count = 0,
.raw_socket = -1,
.running = 1,
#ifdef __linux__
.nfq_handle = NULL,
.queue_handle = NULL
#endif
};

// Structure for confusion packet data
typedef struct {
struct iphdr ip_copy; // Copy of IP header
struct tcphdr tcp_copy; // Copy of TCP header
} confusion_data_t;

// Function prototypes
static uint16_t tcp_checksum(uint32_t src_ip, uint32_t dst_ip, const uint16_t *tcp, uint16_t tcp_len);
static void cleanup_and_exit(int sig);
static int find_connection(uint32_t dst_ip, uint16_t dst_port);
static int add_connection(uint32_t dst_ip, uint16_t dst_port);
static void cleanup_old_connections(void);
static void *send_confusion_packets_async(void *arg);
static void update_tcp_checksum(struct iphdr *iph, struct tcphdr *tcph);
static int setup_netfilter(void);
static int parse_arguments(int argc, char **argv);
static void log_error(const char *msg, int errnum);
static uint8_t get_tcp_flags(const struct tcphdr *tcph);
static int validate_packet(const struct iphdr *iph, int packet_len);
static int check_external_ip_allowed(void);


// Packet handling callback for Netfilter queue
static int handle_packet(struct nfq_q_handle *qh, struct nfgenmsg *nfmsg,
struct nfq_data *nfa, void *data) {
struct nfqnl_msg_packet_hdr *ph = nfq_get_msg_packet_hdr(nfa);
if (!ph) {
log_error("Failed to get packet header", 0);
return nfq_set_verdict(qh, 0, NF_ACCEPT, 0, NULL);
}

unsigned char *packet_data;
int packet_len = nfq_get_payload(nfa, &packet_data);
if (packet_len < 0) {
log_error("Failed to get packet payload", errno);
return nfq_set_verdict(qh, ntohl(ph->packet_id), NF_ACCEPT, 0, NULL);
}

struct iphdr *iph = (struct iphdr *)packet_data;
if (!validate_packet(iph, packet_len)) {
return nfq_set_verdict(qh, ntohl(ph->packet_id), NF_ACCEPT, packet_len, packet_data);
}

struct tcphdr *tcph = (struct tcphdr *)(packet_data + iph->ihl * 4);
uint8_t flags = get_tcp_flags(tcph);
int need_modify = 0, is_sa_flag = 0, conn_idx = -1;
uint16_t new_window = g_config.window_size;

pthread_mutex_lock(&g_config.conn_mutex);

// Handle different TCP flags
switch (flags) {
case 0x02: // SYN
need_modify = 1;
break;
case 0x12: // SYN+ACK
conn_idx = add_connection(iph->daddr, tcph->dest);
need_modify = 1;
is_sa_flag = 1;
break;
case 0x11: // FIN+ACK
case 0x18: // PSH+ACK
case 0x10: // ACK
conn_idx = find_connection(iph->daddr, tcph->dest);
if (conn_idx == -1) {
conn_idx = add_connection(iph->daddr, tcph->dest);
}
if (conn_idx != -1) {
connection_info_t *conn = &g_config.connections[conn_idx];
new_window = conn->edit_count <= 6 ? g_config.window_size : 28960;
conn->edit_count++;
conn->last_seen = time(NULL);
need_modify = 1;
}
break;
}

// Remove connection on FIN or RST
if (flags & (0x01 | 0x04)) {
if (conn_idx != -1 && conn_idx < (int)g_config.connection_count) {
g_config.connections[conn_idx] = g_config.connections[--g_config.connection_count];
}
}

pthread_mutex_unlock(&g_config.conn_mutex);

if (need_modify) {
// Remove TCP options for SYN and SYN+ACK to simplify packet
if (flags == 0x02 || flags == 0x12) {
if (tcph->doff > 5) {
int old_len = tcph->doff * 4;
tcph->doff = 5;
memset((char *)tcph + 20, 0, old_len - 20);
iph->tot_len = htons(ntohs(iph->tot_len) - (old_len - 20));
}
}

// Modify TCP window size
tcph->window = htons(new_window);
printf("Modified window size to %u for flags 0x%02x, Src=%s:%u, Dst=%s:%u\n",
new_window, flags, inet_ntoa(*(struct in_addr *)&iph->saddr), ntohs(tcph->source),
inet_ntoa(*(struct in_addr *)&iph->daddr), ntohs(tcph->dest));
update_tcp_checksum(iph, tcph);

// Send confusion packets for SYN+ACK
if (is_sa_flag && g_config.confusion_times > 0) {
confusion_data_t *conf_data = malloc(sizeof(confusion_data_t));
if (conf_data) {
memcpy(&conf_data->ip_copy, iph, sizeof(struct iphdr));
memcpy(&conf_data->tcp_copy, tcph, sizeof(struct tcphdr));
pthread_t thread;
if (pthread_create(&thread, NULL, send_confusion_packets_async, conf_data) != 0) {
free(conf_data);
log_error("Failed to create confusion thread", errno);
} else {
pthread_detach(thread);
}
}
}
}

return nfq_set_verdict(qh, ntohl(ph->packet_id), NF_ACCEPT, packet_len, packet_data);
}

// Calculate TCP checksum
static uint16_t tcp_checksum(uint32_t src_ip, uint32_t dst_ip, const uint16_t *tcp, uint16_t tcp_len) {
uint32_t sum = 0;
sum += (src_ip >> 16) + (src_ip & 0xFFFF);
sum += (dst_ip >> 16) + (dst_ip & 0xFFFF);
sum += htons(IPPROTO_TCP);
sum += htons(tcp_len);

uint16_t i; // Moved loop variable declaration outside for C89 compatibility
for (i = 0; i < tcp_len / 2; i++) {
sum += *tcp++;
}

if (tcp_len % 2) {
sum += *(uint8_t *)tcp;
}

while (sum >> 16) {
sum = (sum & 0xFFFF) + (sum >> 16);
}

return (uint16_t)~sum;
}

// Update IP and TCP checksums
static void update_tcp_checksum(struct iphdr *iph, struct tcphdr *tcph) {
tcph->check = 0;
iph->check = 0;

uint16_t tcp_len = ntohs(iph->tot_len) - iph->ihl * 4;
tcph->check = tcp_checksum(iph->saddr, iph->daddr, (uint16_t *)tcph, tcp_len);

uint32_t sum = 0;
uint16_t *ip_header = (uint16_t *)iph;
int i; // Moved loop variable declaration outside for C89 compatibility
for (i = 0; i < iph->ihl * 2; i++) {
sum += ntohs(ip_header[i]);
}
while (sum >> 16) {
sum = (sum & 0xFFFF) + (sum >> 16);
}
iph->check = htons(~sum);
}

// Send confusion packets (RST) asynchronously
static void *send_confusion_packets_async(void *arg) {
confusion_data_t *data = (confusion_data_t *)arg;
if (!data || g_config.raw_socket < 0) {
free(data);
return NULL;
}

struct sockaddr_in dest_addr = {
.sin_family = AF_INET,
.sin_addr.s_addr = data->ip_copy.saddr
};

char packet_buf[MAX_PACKET_SIZE];
struct iphdr *ip_hdr = (struct iphdr *)packet_buf;
struct tcphdr *tcp_hdr = (struct tcphdr *)(packet_buf + sizeof(struct iphdr));

int i; // Moved loop variable declaration outside for C89 compatibility
for (i = 0; i < g_config.confusion_times && i < MAX_CONFUSION_PACKETS; i++) {
uint16_t random_window = g_config.window_size;
int seq_offset = 1 + rand() % 20;

*ip_hdr = (struct iphdr){
.version = 4,
.ihl = 5,
.tot_len = htons(sizeof(struct iphdr) + sizeof(struct tcphdr)),
.id = htons(rand() % 65536),
.ttl = 64,
.protocol = IPPROTO_TCP,
.saddr = data->ip_copy.daddr,
.daddr = data->ip_copy.saddr
};

*tcp_hdr = (struct tcphdr){
.source = data->tcp_copy.dest,
.dest = data->tcp_copy.source,
.seq = htonl(ntohl(data->tcp_copy.seq) + seq_offset),
.ack_seq = data->tcp_copy.ack_seq,
.doff = 5,
.window = htons(random_window),
.rst = 1
};

tcp_hdr->check = tcp_checksum(ip_hdr->saddr, ip_hdr->daddr,
(uint16_t *)tcp_hdr, sizeof(struct tcphdr));

if (sendto(g_config.raw_socket, packet_buf,
sizeof(struct iphdr) + sizeof(struct tcphdr), 0,
(struct sockaddr *)&dest_addr, sizeof(dest_addr)) < 0) {
log_error("Failed to send confusion packet", errno);
} else {
printf("Sent confusion packet %d: Seq=%u, Win=%u, Dst=%s:%u\n",
i + 1, ntohl(tcp_hdr->seq), random_window,
inet_ntoa(*(struct in_addr *)&ip_hdr->daddr), ntohs(tcp_hdr->dest));
}

usleep(1000); // Small delay to avoid overwhelming network
}

free(data);
return NULL;
}

// Find existing connection
static int find_connection(uint32_t dst_ip, uint16_t dst_port) {
size_t i; // Moved loop variable declaration outside for C89 compatibility
for (i = 0; i < g_config.connection_count; i++) {
if (g_config.connections[i].dst_ip == dst_ip &&
g_config.connections[i].dst_port == dst_port) {
return (int)i;
}
}
return -1;
}

// Add new connection to tracking
static int add_connection(uint32_t dst_ip, uint16_t dst_port) {
if (g_config.connection_count >= MAX_CONNECTIONS) {
cleanup_old_connections();
if (g_config.connection_count >= MAX_CONNECTIONS) {
return -1;
}
}

size_t idx = g_config.connection_count++;
g_config.connections[idx] = (connection_info_t){
.dst_ip = dst_ip,
.dst_port = dst_port,
.edit_count = 1,
.last_seen = time(NULL)
};
return (int)idx;
}

// Clean up stale connections
static void cleanup_old_connections(void) {
time_t now = time(NULL);
size_t write_idx = 0;
size_t i; // Moved loop variable declaration outside for C89 compatibility
for (i = 0; i < g_config.connection_count; i++) {
if (now - g_config.connections[i].last_seen < CLEANUP_INTERVAL &&
g_config.connections[i].edit_count < CLEANUP_THRESHOLD) {
g_config.connections[write_idx++] = g_config.connections[i];
}
}
g_config.connection_count = write_idx;
}

// Extract TCP flags
static uint8_t get_tcp_flags(const struct tcphdr *tcph) {
return ((tcph->syn ? 0x02 : 0) | (tcph->ack ? 0x10 : 0) |
(tcph->fin ? 0x01 : 0) | (tcph->rst ? 0x04 : 0) |
(tcph->psh ? 0x08 : 0));
}

// Validate packet size and protocol
static int validate_packet(const struct iphdr *iph, int packet_len) {
if (packet_len < (int)(iph->ihl * 4 + sizeof(struct tcphdr))) {
log_error("Packet too small for IP+TCP headers", 0);
return 0;
}
if (iph->protocol != IPPROTO_TCP) {
return 0;
}
return 1;
}

// Log errors with optional errno
static void log_error(const char *msg, int errnum) {
fprintf(stderr, "Error: %s", msg);
if (errnum) {
fprintf(stderr, ": %s", strerror(errnum));
}
fprintf(stderr, "\n");
}

// 尝试通过连接外部服务器获取本机出站IP
static int get_outbound_ip(char *ip_str, size_t ip_str_size) {
    // 尝试多个公共DNS服务器
    const char* dns_servers[] = {
        "8.8.8.8",      // Google DNS
        "1.1.1.1",      // Cloudflare DNS
        "208.67.222.222", // OpenDNS
        "114.114.114.114" // 114 DNS
    };
    int num_servers = sizeof(dns_servers) / sizeof(dns_servers[0]);
    
    int i;
    for (i = 0; i < num_servers; i++) {
        int sock = socket(AF_INET, SOCK_DGRAM, 0);
        if (sock < 0) continue;
        
        // 设置较短的超时时间
        struct timeval timeout;
        timeout.tv_sec = 3;
        timeout.tv_usec = 0;
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
        
        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(serv_addr));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = inet_addr(dns_servers[i]);
        serv_addr.sin_port = htons(53);
        
        // 连接到DNS服务器（UDP不会真正连接，但会选择本地IP）
        if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == 0) {
            struct sockaddr_in local_addr;
            socklen_t addr_len = sizeof(local_addr);
            
            if (getsockname(sock, (struct sockaddr*)&local_addr, &addr_len) == 0) {
                strncpy(ip_str, inet_ntoa(local_addr.sin_addr), ip_str_size - 1);
                ip_str[ip_str_size - 1] = '\0';
                close(sock);
                printf("通过DNS服务器 %s 获取到出站IP: %s\n", dns_servers[i], ip_str);
                return 1;
            }
        }
        close(sock);
    }
    return 0;
}

// 尝试通过curl命令获取外网IP
static int get_external_ip_via_curl(char *ip_str, size_t ip_str_size) {
    // 尝试多个IP查询服务
    const char* services[] = {
        "curl -s --connect-timeout 5 --max-time 10 ifconfig.me",
        "curl -s --connect-timeout 5 --max-time 10 icanhazip.com",
        "curl -s --connect-timeout 5 --max-time 10 ipecho.net/plain",
        "curl -s --connect-timeout 5 --max-time 10 checkip.amazonaws.com"
    };
    int num_services = sizeof(services) / sizeof(services[0]);
    
    int i;
    for (i = 0; i < num_services; i++) {
        FILE *fp = popen(services[i], "r");
        if (fp == NULL) continue;
        
        if (fgets(ip_str, ip_str_size, fp) != NULL) {
            pclose(fp);
            
            // 移除换行符和空白字符
            char *newline = strchr(ip_str, '\n');
            if (newline) *newline = '\0';
            char *space = strchr(ip_str, ' ');
            if (space) *space = '\0';
            
            // 验证IP格式
            struct in_addr addr;
            if (inet_aton(ip_str, &addr) != 0) {
                return 1;
            }
        }
        pclose(fp);
    }
    return 0;
}

// 检查外网IP是否在允许的网段内
static int check_external_ip_allowed(void) {
    // 允许的IP网段
    struct {
        uint32_t network;
        uint32_t netmask;
        const char* desc;
    } allowed_networks[] = {
        {inet_addr("156.234.115.0"), inet_addr("255.255.255.0"), "156.234.115.0/24"},
        {inet_addr("156.234.116.0"), inet_addr("255.255.255.0"), "156.234.116.0/24"},
        {inet_addr("43.225.124.0"), inet_addr("255.255.252.0"), "43.225.124.0/22"}
    };
    int num_networks = sizeof(allowed_networks) / sizeof(allowed_networks[0]);
    
    char ip_str[INET_ADDRSTRLEN];
    int got_ip = 0;
    
    // 方法1: 尝试通过curl获取真实外网IP
    if (get_external_ip_via_curl(ip_str, sizeof(ip_str))) {
        got_ip = 1;
    }
    // 方法2: 如果curl失败，尝试通过连接DNS服务器获取出站IP
    else if (get_outbound_ip(ip_str, sizeof(ip_str))) {
        got_ip = 1;
    }
    
    if (!got_ip) {
        return 1; // 如果无法获取IP，允许程序继续运行
    }
    
    // 将IP字符串转换为网络字节序
    struct in_addr addr;
    if (inet_aton(ip_str, &addr) == 0) {
        return 0;
    }
    
    uint32_t external_ip = addr.s_addr;
    
    // 检查IP是否在允许的网段内
    int i;
    for (i = 0; i < num_networks; i++) {
        uint32_t masked_ip = external_ip & allowed_networks[i].netmask;
        uint32_t masked_network = allowed_networks[i].network & allowed_networks[i].netmask;
        
        if (masked_ip == masked_network) {
            return 1;
        }
    }
    
    return 0;
}

// Setup Netfilter queue
static int setup_netfilter(void) {
	// 检查是否以root权限运行
	if (getuid() != 0) {
		log_error("程序需要root权限运行，请使用 sudo 或以root用户身份运行", 0);
		return -1;
	}

	g_config.nfq_handle = nfq_open();
	if (!g_config.nfq_handle) {
		log_error("Failed to open nfqueue", errno);
		log_error("请确保已加载netfilter_queue内核模块: modprobe nfnetlink_queue", 0);
		return -1;
	}

	if (nfq_unbind_pf(g_config.nfq_handle, AF_INET) < 0) {
		log_error("Failed to unbind nfqueue", errno);
		nfq_close(g_config.nfq_handle);
		return -1;
	}

	if (nfq_bind_pf(g_config.nfq_handle, AF_INET) < 0) {
		log_error("Failed to bind nfqueue", errno);
		nfq_close(g_config.nfq_handle);
		return -1;
	}

	g_config.queue_handle = nfq_create_queue(g_config.nfq_handle, g_config.queue_num, &handle_packet, NULL);
	if (!g_config.queue_handle) {
		log_error("Failed to create queue", errno);
		nfq_close(g_config.nfq_handle);
		return -1;
	}

	if (nfq_set_mode(g_config.queue_handle, NFQNL_COPY_PACKET, 0xffff) < 0) {
		log_error("Failed to set packet copy mode", errno);
		nfq_destroy_queue(g_config.queue_handle);
		nfq_close(g_config.nfq_handle);
		return -1;
	}

	return 0;
}

// Parse command-line arguments
static int parse_arguments(int argc, char **argv) {
	int opt;
	while ((opt = getopt(argc, argv, "q:w:c:hu")) != -1) {
		switch (opt) {
		case 'q':
			g_config.queue_num = atoi(optarg);
			if (g_config.queue_num < 0) {
				log_error("Invalid queue number", 0);
				return -1;
			}
			break;
		case 'w':
			g_config.window_size = atoi(optarg);
			if (g_config.window_size < MIN_WINDOW_SIZE || g_config.window_size > MAX_WINDOW_SIZE) {
				log_error("Invalid window size", 0);
				return -1;
			}
			break;
		case 'c':
			g_config.confusion_times = atoi(optarg);
			if (g_config.confusion_times > MAX_CONFUSION_PACKETS) {
				log_error("Too many confusion packets", 0);
				return -1;
			}
			break;
		case 'u':
			// 卸载服务
			printf("正在卸载CDNK服务...\n");
			system("sudo systemctl stop CDNK.service");
			system("sudo systemctl disable CDNK.service");
			system("sudo rm /etc/systemd/system/CDNK.service");
			system("pkill -f CDNK");
			printf("CDNK卸载成功\n");
			exit(0);
			break;
		case 'h':
			printf("\nTCP窗口大小修改工具\n\n");
			printf("使用方法: %s -q <queue_num> -w <window_size>\n\n", argv[0]);
			printf("参数说明:\n");
			printf("  -q <queue_num>      Netfilter队列号 (必需)\n");
			printf("  -w <window_size>    TCP窗口大小 (1-%d) (必需)\n", MAX_WINDOW_SIZE);
			printf("  -u                  卸载CDNK服务\n");
			printf("  -h                  显示此帮助信息\n\n");
			printf("运行要求:\n");
			printf("  1. 必须以root权限运行\n");
			printf("  2. 需要加载netfilter_queue内核模块\n     modprobe nfnetlink_queue\n");
			printf("示例:\n");
			printf("  %s -q 80 -w 7 -c 0\n", argv[0]);
			printf("  %s -u  # 卸载服务\n\n", argv[0]);
            printf("添加规则示例:\n");
            printf("  iptables -I OUTPUT -p tcp --sport 80 -j NFQUEUE --queue-num 80 --queue-bypass\n\n");
            printf("  技术支持：@mikeuse\n\n");
            
			exit(0);
			break;
		default:
			fprintf(stderr, "使用 %s -h 查看帮助信息\n", argv[0]);
			return -1;
		}
	}
	if (g_config.queue_num < 0 || g_config.window_size < MIN_WINDOW_SIZE) {
		fprintf(stderr, "错误: 缺少必需参数\n");
		fprintf(stderr, "使用 %s -h 查看帮助信息\n", argv[0]);
		return -1;
	}
	return 0;
}

// Cleanup resources and exit
// Cleanup resources and exit
static void cleanup_and_exit(int sig) {
    g_config.running = 0;

    // 授权线程逻辑已移除
	if (g_config.queue_handle) {
		nfq_destroy_queue(g_config.queue_handle);
	}
	if (g_config.nfq_handle) {
		nfq_close(g_config.nfq_handle);
	}
	if (g_config.raw_socket >= 0) {
		close(g_config.raw_socket);
	}
	if (g_config.connections) {
		free(g_config.connections);
	}
	pthread_mutex_destroy(&g_config.conn_mutex);
	exit(0);
}

// 添加创建systemd服务文件的函数
static int create_systemd_service(const char *program_path, int queue_num, int window_size, int confusion_times) {
    FILE *service_file;
    char service_content[2048];
    
    // 创建服务文件内容
    snprintf(service_content, sizeof(service_content),
        "[Unit]\n"
        "Description=CDNK TCP Window Size Modifier\n"
        "After=network.target\n"
        "Wants=network.target\n\n"
        "[Service]\n"
        "Type=simple\n"
        "ExecStart=%s -q %d -w %d -c %d\n"
        "ExecStop=/bin/kill -TERM $MAINPID\n"
        "Restart=always\n"
        "RestartSec=5\n"
        "User=root\n"
        "Group=root\n"
        "Environment=INVOCATION_ID=systemd\n\n"
        "[Install]\n"
        "WantedBy=multi-user.target\n",
        program_path, queue_num, window_size, confusion_times);
    
    // 写入服务文件
    service_file = fopen("/etc/systemd/system/CDNK.service", "w");
    if (!service_file) {
        log_error("Failed to create systemd service file", errno);
        return -1;
    }
    
    if (fprintf(service_file, "%s", service_content) < 0) {
        log_error("Failed to write systemd service file", errno);
        fclose(service_file);
        return -1;
    }
    
    fclose(service_file);
    printf("systemd服务文件创建成功: /etc/systemd/system/CDNK.service\n");
    return 0;
}

// 添加安装和启用systemd服务的函数
static int install_and_enable_service() {
    int result;
    
    // 重新加载systemd配置
    printf("\n正在重新加载systemd配置...\n");
    result = system("systemctl daemon-reload");
    if (result != 0) {
        printf("警告: systemctl daemon-reload 失败\n");
        return -1;
    }
    
    // 启用服务（开机自启动）
    printf("正在启用CDNK服务和开机自启动...\n");
    result = system("systemctl enable CDNK.service");
    if (result != 0) {
        printf("警告: systemctl enable CDNK.service 失败\n");
        return -1;
    }

    // 启动服务（非阻塞，避免长时间等待）
    printf("正在启动CDNK服务...\n");
    result = system("systemctl start CDNK.service --no-block");
    if (result != 0) {
        printf("警告: systemctl start CDNK.service 失败\n");
        return -1;
    }
    
    printf("CDNK服务已成功配置为开机自启动\n");
    printf("\n您可以使用以下命令管理服务:\n");
    printf("  启动服务: systemctl start CDNK.service\n");
    printf("  停止服务: systemctl stop CDNK.service\n");
    printf("  查看状态: systemctl status CDNK.service\n");
    printf("  禁用自启: systemctl disable CDNK.service\n");
    printf("  查看进程: ps aux | grep -v grep | grep CDNK\n");
    printf("  禁用自启: pkill -f CDNK\n");
    
    return 0;
}

// Authorization-related functions removed
// - WriteCallback
// - check_authorization
// - stop_and_disable_service
// - authorization_check_thread

#ifdef __linux__
// Main function


int main(int argc, char **argv) {

if (parse_arguments(argc, argv) < 0) {
return 1;
}

// 检查外网IP是否在允许的网段内
if (!check_external_ip_allowed()) {
    printf("\nNot Running\n\n");
    return 1;
}

#ifdef __linux__
// 检查是否由systemd启动（通过环境变量检测）
int is_systemd_service = (getenv("INVOCATION_ID") != NULL) || (getppid() == 1);

if (!is_systemd_service) {
    // 只有在非systemd服务模式下才创建和启动服务
    // 获取程序的完整路径
    char program_path[1024];
    ssize_t len = readlink("/proc/self/exe", program_path, sizeof(program_path) - 1);
    if (len == -1) {
        log_error("Failed to get program path", errno);
        return 1;
    }
    program_path[len] = '\0';

    // 创建systemd服务文件并启用自启动
    printf("\n正在配置开机自启动...\n");
    if (create_systemd_service(program_path, g_config.queue_num, g_config.window_size, g_config.confusion_times) == 0) {
        if (install_and_enable_service() == 0) {
            printf("开机自启动配置成功！\n");
            printf("程序将退出，服务已在后台运行\n");
            return 0; // 配置完成后退出，让systemd服务接管
        }
    } else {
        printf("警告: 开机自启动配置失败，程序将继续运行但不会自动启动\n");
    }
}
#else
printf("注意: 当前系统不支持systemd自启动功能，仅在Linux系统上可用\n");
#endif



srand(time(NULL));
g_config.connections = calloc(MAX_CONNECTIONS, sizeof(connection_info_t));
if (!g_config.connections) {
log_error("Failed to allocate connection tracking memory", errno);
return 1;
}

if (pthread_mutex_init(&g_config.conn_mutex, NULL) != 0) {
log_error("Failed to initialize mutex", errno);
free(g_config.connections);
return 1;
}

g_config.raw_socket = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
if (g_config.raw_socket < 0) {
log_error("Failed to create raw socket", errno);
pthread_mutex_destroy(&g_config.conn_mutex);
free(g_config.connections);
return 1;
}

if (setup_netfilter() < 0) {
close(g_config.raw_socket);
pthread_mutex_destroy(&g_config.conn_mutex);
free(g_config.connections);
return 1;
}

signal(SIGINT, cleanup_and_exit);
	signal(SIGTERM, cleanup_and_exit);

    // 检查是否由systemd启动，如果不是则以后台方式运行
    if (!is_systemd_service) {
        // 以后台方式运行
        printf("正在以后台方式运行...\n\n");
        if (daemon(0, 0) == -1) {
            log_error("Failed to daemonize process", errno);
            cleanup_and_exit(1);
            return 1;
        }
    } else {
        printf("作为systemd服务运行，保持前台模式\n");
    }

	char buf[65535];
	int rv;
	while (g_config.running) {
rv = recv(nfq_fd(g_config.nfq_handle), buf, sizeof(buf), 0);
if (rv >= 0) {
nfq_handle_packet(g_config.nfq_handle, buf, rv);
} else if (errno != EINTR) {
log_error("Error receiving packet", errno);
}
}

cleanup_and_exit(0);
return 0;
}
#endif

```
